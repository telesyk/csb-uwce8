{"version":3,"sources":["src/config.js","src/confStyles.js","src/helpers/create.js","src/helpers/render.js","src/helpers/handlers.js","node_modules/prismjs/prism.js","src/helpers/highlight.js","src/helpers/index.js","src/view/cardio1.js","src/view/cardio2.js","src/view/cardio3.js","src/view/index.js","src/components/button.js","src/components/nav.js","src/index.js"],"names":["tabs","selector","rootNode","tabViewId","codeNode","coverCodeNode","codeBlock","defaultNode","triggerCode","tabTitle","navContainer","navIndex","highlight","type","styles","block","blockTitle","blockCode","codeWrapper","trigger","class","icon","toggle","height","gaps","wrapper","container","nav","default","active","config","createElement","content","elementTag","elementType","element","document","Node","appendChild","textContent","createElementCode","result","elementCode","elementCoverCode","className","createBlockCode","fnCode","showCode","fragment","createDocumentFragment","elementTriggerIcon","classList","add","elementTrigger","setAttribute","elementFnCode","elementWrapper","append","renderElement","rootId","id","getElementById","console","log","renderBlock","nodeId","args","code","text","defaultShowCode","undefined","blockElement","titleElement","title","description","descriptionElement","resultElement","codeElement","toString","renderTab","tabIndex","tab","elementTab","innerHTML","elementTitle","examples","map","sample","handleActiveNavItem","target","querySelector","childNodes","forEach","item","triggerDisplayCodeArea","elementCodeArea","nextElementSibling","firstElementChild","handleDisplayCode","event","getAttribute","setCodeHighlights","codeHighlighted","Prism","innerText","languages","reverseString","str","split","reverse","join","stringReverseString","reverseStringOpt","isPalindrom","revStr","stringIsPalindrom","isPalindromOpt","capitalize","word","toUpperCase","substring","stringCapitalize","capitalizeOpt","revInteger","int","parseInt","Math","sign","stringRevInteger","revIntegerOpt","mostCommonChar","charMap","maxChar","maxNum","char","stringMostCommonChar","mostCommonCharOpt","fizzBuzz","i","longestWord","sen","wArr","sorted","toLowerCase","match","sort","a","b","length","long","filter","w","stringLongestWord","longestWordOpt","chunkArr","arr","len","chunkedArr","push","slice","stringChunkArr","chunkArrOpt","flattenArr","arrays","concat","stringFlattenArr","flattenArrOpt","isAnagram","str1","str2","case1","stringIsAnagram","isAnagramOpt","Array","prototype","duplicate","stringDuplicate","duplicateArrOpt","shiftLetters","newStr","replace","String","fromCharCode","charCodeAt","stringShiftLetters","shiftLettersOpt","arrPrices","sortPrice","prices","filtered","p","stringsortPrice","sortPriceOpt","closureFunc","n","cl1","stringClosureFn","closureFuncOpt","addAll","rest","reduce","sum","stringAddAll","addAllOpt","isPrime","num","stringIsPrime","isPrimeOpt","sumPrimeNum","stringSumPrimeNum","sumPrimeNumOpt","tabCardio1","tabCardio2","tabCardio3","Button","props","classname","attrs","attr","attrName","Object","getOwnPropertyNames","Nav","items","newItem","viewState","tabsRevers","findIndex","activeTabIndex","navItems","index","highlightCode","from","querySelectorAll","addEventListener"],"mappings":"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","file":"src.03015a53.js","sourceRoot":"..","sourcesContent":["export default {\n  tabs: [],\n  selector: {\n    rootNode: \"app\",\n    tabViewId: \"tab\",\n    codeNode: \"code\",\n    coverCodeNode: \"pre\",\n    codeBlock: \"pre > code\",\n    defaultNode: \"div\",\n    triggerCode: \"data-target\",\n    tabTitle: \"h1\",\n    navContainer: \"nav\",\n    navIndex: \"tab-index\"\n  },\n  highlight: {\n    type: \"javascript\"\n  }\n};\n","const styles = {\n  tabTitle: \"text-3xl mb-6\",\n  block: \"code mb-5 pb-5 text-sm\",\n  blockTitle: \"text-xl text-gray-200\",\n  blockCode:\n    \"my-2 p-2 border-b-2 border-blue-900 rounded bg-gray-900 text-gray-300\",\n  codeWrapper: {\n    trigger: {\n      class: \"flex justify-end bg-gray-300 text-gray-600 cursor-pointer\",\n      icon: \"px-2 transition-all transform\"\n    },\n    toggle: {\n      height: \"h-0\",\n      gaps: \"p-2\",\n      icon: \"rotate-45\"\n    },\n    wrapper: \"code-wrapper my-3\",\n    container:\n      \"code-container border-b-2 border-blue-900 rounded rounded-t-none bg-gray-900 text-gray-300 overflow-y-hidden\"\n  },\n  nav: {\n    default: \"bg-gray-300 text-gray-800 py-1 px-3\",\n    active: \"bg-gray-50 text-gray-800 py-1 px-3\",\n    container: \"flex justify-center gap-x-2\"\n  }\n};\n\nexport default styles;\n","import styles from \"../confStyles\";\nimport config from \"../config\";\n\nconst { selector } = config;\n\nconst createElement = (content, elementTag) => {\n  const elementType = elementTag || selector.defaultNode;\n  const element = document.createElement(elementType);\n\n  if (content) {\n    if (content instanceof Node) {\n      element.appendChild(content);\n    } else {\n      element.textContent = content;\n    }\n  }\n\n  return element;\n};\n\n/*\n * Create block to show result,\n * for example some function execution\n */\nconst createElementCode = (result) => {\n  const elementCode = createElement(result, selector.codeNode);\n  const elementCoverCode = createElement(elementCode, selector.coverCodeNode);\n  elementCoverCode.className = styles.blockCode;\n\n  return elementCoverCode;\n};\n\n/*\n * Create block to show result,\n * for example body (code) of some function\n */\nconst createBlockCode = (fnCode, showCode) => {\n  const fragment = document.createDocumentFragment();\n  const elementTriggerIcon = createElement(\"+\");\n  elementTriggerIcon.className = styles.codeWrapper.trigger.icon;\n  if (showCode)\n    elementTriggerIcon.classList.add(styles.codeWrapper.toggle.icon);\n\n  const elementTrigger = createElement(elementTriggerIcon);\n  elementTrigger.setAttribute(selector.triggerCode, true);\n  elementTrigger.className = styles.codeWrapper.trigger.class;\n\n  const elementFnCode = createElementCode(fnCode);\n  elementFnCode.className = styles.codeWrapper.container;\n  if (!showCode) {\n    elementFnCode.classList.add(styles.codeWrapper.toggle.height);\n  } else {\n    elementFnCode.classList.add(styles.codeWrapper.toggle.gaps);\n  }\n\n  /** Container (wrapper) that includes code & trigger elements */\n  const elementWrapper = createElement(elementTrigger);\n  elementWrapper.className = styles.codeWrapper.wrapper;\n  elementWrapper.append(elementFnCode);\n\n  fragment.append(elementWrapper);\n\n  return fragment;\n};\n\nexport { createElement, createBlockCode, createElementCode };\n","import styles from \"../confStyles\";\nimport config from \"../config\";\nimport { createElementCode, createBlockCode, createElement } from \"./create\";\n\nconst { selector } = config;\n\nconst renderElement = (element, rootId) => {\n  if (!element) {\n    console.log(\"[Need to define element]\", element);\n    return;\n  }\n\n  const id = !rootId ? selector.rootNode : rootId;\n  const rootEl = document.getElementById(id);\n\n  rootEl.appendChild(element);\n};\n\nconst renderBlock = (nodeId, ...args) => {\n  if (!nodeId || typeof nodeId !== \"string\") return;\n\n  const [code, result, text, showCode] = args;\n  /**\n   * defaultShowCode - to show blocks with code by default\n   */\n  const defaultShowCode = showCode === undefined ? true : showCode;\n  const blockElement = createElement();\n  blockElement.className = styles.block;\n\n  if (text) {\n    const titleElement = createElement(null, \"h2\");\n    titleElement.className = styles.blockTitle;\n    blockElement.appendChild(titleElement);\n\n    if (typeof text === \"string\") titleElement.textContent = text;\n    if (text.title) titleElement.textContent = text.title;\n    if (text.description) {\n      const descriptionElement = createElementCode(text.description);\n      blockElement.appendChild(descriptionElement);\n    }\n  }\n\n  if (result) {\n    const resultElement = createElementCode(result);\n    blockElement.appendChild(resultElement);\n  }\n\n  if (!!code) {\n    const codeElement = createBlockCode(code.toString(), !!defaultShowCode);\n    blockElement.appendChild(codeElement);\n  }\n\n  return renderElement(blockElement, nodeId);\n};\n\nconst renderTab = (tabs, tabIndex) => {\n  const { tabViewId, tabTitle, rootNode } = selector;\n  const index = !tabIndex ? 0 : tabIndex;\n  const tab = tabs[index];\n  let elementTab = null;\n\n  if (!document.getElementById(tabViewId)) {\n    elementTab = createElement();\n    elementTab.id = tabViewId;\n  } else {\n    elementTab = document.getElementById(tabViewId);\n    elementTab.innerHTML = \"\";\n  }\n\n  const elementTitle = createElement(tab.title, tabTitle);\n\n  elementTitle.className = styles.tabTitle;\n\n  renderElement(elementTab, rootNode);\n  renderElement(elementTitle, tabViewId);\n\n  tab.examples.map((sample) => renderBlock(tabViewId, ...sample));\n\n  return elementTab;\n};\n\nexport { renderBlock, renderElement, renderTab };\n","import styles from \"../confStyles\";\nimport config from \"../config\";\n\nconst { codeWrapper, nav } = styles;\nconst { selector } = config;\n\nconst handleActiveNavItem = (target) => {\n  const navContainer = document.querySelector(selector.navContainer);\n  const navItems = navContainer.childNodes;\n  navItems.forEach((item) => {\n    item.className = nav.default;\n  });\n\n  target.className = nav.active;\n};\n\nconst triggerDisplayCodeArea = (target) => {\n  const elementCodeArea = target.nextElementSibling;\n  elementCodeArea.classList.toggle(codeWrapper.toggle.height);\n  elementCodeArea.classList.toggle(codeWrapper.toggle.gaps);\n\n  const elementTriggerIcon = target.firstElementChild;\n  elementTriggerIcon.classList.toggle(codeWrapper.toggle.icon);\n};\n\nconst handleDisplayCode = (event) => {\n  const target = event.target;\n  if (!target.getAttribute(selector.triggerCode)) return;\n  return triggerDisplayCodeArea(target);\n};\n\nexport { handleDisplayCode, handleActiveNavItem };\n","\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\n/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element && !lang.test(element.className)) {\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\tif (element) {\n\t\t\t\t\treturn (element.className.match(lang) || [, 'none'])[1].toLowerCase();\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prism’s API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\n(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:prototype|constructor))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\tpattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t}\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\t}\n\n\tvar LOADING_MESSAGE = 'Loading…';\n\tvar FAILURE_MESSAGE = function (status, message) {\n\t\treturn '✖ Error ' + status + ' while fetching file: ' + message;\n\t};\n\tvar FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';\n\n\tvar EXTENSIONS = {\n\t\t'js': 'javascript',\n\t\t'py': 'python',\n\t\t'rb': 'ruby',\n\t\t'ps1': 'powershell',\n\t\t'psm1': 'powershell',\n\t\t'sh': 'bash',\n\t\t'bat': 'batch',\n\t\t'h': 'c',\n\t\t'tex': 'latex'\n\t};\n\n\tvar STATUS_ATTR = 'data-src-status';\n\tvar STATUS_LOADING = 'loading';\n\tvar STATUS_LOADED = 'loaded';\n\tvar STATUS_FAILED = 'failed';\n\n\tvar SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])'\n\t\t+ ':not([' + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n\n\tvar lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;\n\n\t/**\n\t * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.\n\t *\n\t * @param {HTMLElement} element\n\t * @param {string} language\n\t * @returns {void}\n\t */\n\tfunction setLanguageClass(element, language) {\n\t\tvar className = element.className;\n\t\tclassName = className.replace(lang, ' ') + ' language-' + language;\n\t\telement.className = className.replace(/\\s+/g, ' ').trim();\n\t}\n\n\n\tPrism.hooks.add('before-highlightall', function (env) {\n\t\tenv.selector += ', ' + SELECTOR;\n\t});\n\n\tPrism.hooks.add('before-sanity-check', function (env) {\n\t\tvar pre = /** @type {HTMLPreElement} */ (env.element);\n\t\tif (pre.matches(SELECTOR)) {\n\t\t\tenv.code = ''; // fast-path the whole thing and go to complete\n\n\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n\n\t\t\t// add code element with loading message\n\t\t\tvar code = pre.appendChild(document.createElement('CODE'));\n\t\t\tcode.textContent = LOADING_MESSAGE;\n\n\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\tvar language = env.language;\n\t\t\tif (language === 'none') {\n\t\t\t\t// the language might be 'none' because there is no language set;\n\t\t\t\t// in this case, we want to use the extension as the language\n\t\t\t\tvar extension = (/\\.(\\w+)$/.exec(src) || [, 'none'])[1];\n\t\t\t\tlanguage = EXTENSIONS[extension] || extension;\n\t\t\t}\n\n\t\t\t// set language classes\n\t\t\tsetLanguageClass(code, language);\n\t\t\tsetLanguageClass(pre, language);\n\n\t\t\t// preload the language\n\t\t\tvar autoloader = Prism.plugins.autoloader;\n\t\t\tif (autoloader) {\n\t\t\t\tautoloader.loadLanguages(language);\n\t\t\t}\n\n\t\t\t// load file\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\txhr.open('GET', src, true);\n\t\t\txhr.onreadystatechange = function () {\n\t\t\t\tif (xhr.readyState == 4) {\n\t\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\t\t// mark as loaded\n\t\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n\n\t\t\t\t\t\t// highlight code\n\t\t\t\t\t\tcode.textContent = xhr.responseText;\n\t\t\t\t\t\tPrism.highlightElement(code);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// mark as failed\n\t\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n\n\t\t\t\t\t\tif (xhr.status >= 400) {\n\t\t\t\t\t\t\tcode.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcode.textContent = FAILURE_EMPTY_MESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\txhr.send(null);\n\t\t}\n\t});\n\n\tPrism.plugins.fileHighlight = {\n\t\t/**\n\t\t * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n\t\t *\n\t\t * Note: Elements which are already loaded or currently loading will not be touched by this method.\n\t\t *\n\t\t * @param {ParentNode} [container=document]\n\t\t */\n\t\thighlight: function highlight(container) {\n\t\t\tvar elements = (container || document).querySelectorAll(SELECTOR);\n\n\t\t\tfor (var i = 0, element; (element = elements[i++]);) {\n\t\t\t\tPrism.highlightElement(element);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar logged = false;\n\t/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */\n\tPrism.fileHighlight = function () {\n\t\tif (!logged) {\n\t\t\tconsole.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');\n\t\t\tlogged = true;\n\t\t}\n\t\tPrism.plugins.fileHighlight.highlight.apply(this, arguments);\n\t};\n\n}());\n","import Prism from \"prismjs\";\nimport config from \"../config\";\n\nconst {\n  highlight: { type }\n} = config;\n\nconst setCodeHighlights = (codeBlock) => {\n  const codeHighlighted = Prism.highlight(\n    codeBlock.innerText,\n    Prism.languages[type],\n    type\n  );\n  codeBlock.innerHTML = codeHighlighted;\n};\n\nexport default setCodeHighlights;\n","import { renderBlock, renderElement, renderTab } from \"./render\";\nimport { createElement, createBlockCode } from \"./create\";\nimport { handleDisplayCode, handleActiveNavItem } from \"./handlers\";\nimport setCodeHighlights from \"./highlight\";\n\nexport {\n  createElement,\n  createBlockCode,\n  renderBlock,\n  renderElement,\n  renderTab,\n  handleDisplayCode,\n  handleActiveNavItem,\n  setCodeHighlights\n};\n","// const FnOpt = [\n//   fn,\n//   fnCall,\n//   {\n//     title: '',\n//     description: ''\n//   },\n//   true || false || undefined\n// ];\n\nfunction reverseString(str) {\n  /* case 1 */\n  return str.split(\"\").reverse().join(\"\");\n  /* case 2 */\n  // return str.split(\"\").reduce((revStr, char) => char + revStr);\n}\nconst stringReverseString = `function reverseString(str) {\n  /* case 1 */ return str.split(\"\").reverse().join(\"\");\n  /* case 2 */ // return str.split(\"\").reduce((revStr, char) => char + revStr);\n}\n`;\nconst reverseStringOpt = [\n  stringReverseString,\n  reverseString(\"hello\"),\n  {\n    title: \"Return reversed string\",\n    description: \"reverseString('hello')\"\n  },\n  true\n];\n//--------------------\n\nfunction isPalindrom(str) {\n  const revStr = str.split(\"\").reverse().join(\"\");\n  return revStr === str;\n}\nconst stringIsPalindrom = `function isPalindrom(str) {\n  const revStr = str.split(\"\").reverse().join(\"\");\n  return revStr === str;\n}\n`;\nconst isPalindromOpt = [\n  stringIsPalindrom,\n  isPalindrom(\"racecar\"),\n  {\n    title: \"Check for palindrom\",\n    description: \"isPalindrom('racecar')\"\n  }\n];\n//--------------------\n\nfunction capitalize(str) {\n  return str\n    .split(\" \")\n    .map((word) => word[0].toUpperCase() + word.substring(1))\n    .join(\" \");\n}\nconst stringCapitalize = `function capitalize(str) {\n  return str\n    .split(\" \")\n    .map((word) => word[0].toUpperCase() + word.substring(1))\n    .join(\" \");\n}\n`;\nconst capitalizeOpt = [\n  stringCapitalize,\n  capitalize(\"how are you, my dear\"),\n  {\n    title: \"Capitalize text\",\n    description: 'capitalize(\"how are you, my dear\")'\n  }\n];\n//--------------------\n\nfunction revInteger(int) {\n  const revStr = int.toString().split(\"\").reverse().join(\"\"); // convert INT to string\n\n  return parseInt(revStr, 10) * Math.sign(int); // return parseInt(revStr);\n}\nconst stringRevInteger = `function revInteger(int) {\n  const revStr = int.toString().split(\"\").reverse().join(\"\"); // convert INT to string\n  return parseInt(revStr, 10) * Math.sign(int); // return parseInt(revStr);\n}\n`;\nconst revIntegerOpt = [\n  stringRevInteger,\n  revInteger(-12345),\n  {\n    title: \"Revert integer\",\n    description: \"revInteger(-12345)\"\n  }\n];\n//--------------------\n\nfunction mostCommonChar(str) {\n  const charMap = {};\n  let maxChar = \"\";\n  let maxNum = 0;\n\n  str.split(\"\").forEach((char) => {\n    if (!charMap[char]) {\n      charMap[char] = 1;\n    } else {\n      charMap[char]++;\n    }\n  });\n  for (let char in charMap) {\n    if (charMap[char] > maxNum) {\n      maxNum = charMap[char];\n      maxChar = char;\n    }\n  }\n  return maxChar;\n}\nconst stringMostCommonChar = `function mostCommonChar(str) {\n  const charMap = {};\n  let maxChar = \"\";\n  let maxNum = 0;\n\n  str.split(\"\").forEach((char) => {\n    if (!charMap[char]) {\n      charMap[char] = 1;\n    } else {\n      charMap[char]++;\n    }\n  });\n  for (let char in charMap) {\n    if (charMap[char] > maxNum) {\n      maxNum = charMap[char];\n      maxChar = char;\n    }\n  }\n  return maxChar;\n}`;\nconst mostCommonCharOpt = [\n  stringMostCommonChar,\n  mostCommonChar(\"javascriptt\"),\n  {\n    title: \"Get most common character\",\n    description: \"mostCommonChar('javascripttt')\"\n  }\n];\n//--------------------\n\nfunction fizzBuzz() {\n  for (let i = 1; i <= 100; i++) {\n    if (i % 3 === 0 && i % 5 === 0) {\n      console.log(\"FizzBuzz\");\n    } else if (i % 3 === 0) {\n      console.log(\"Fizz\");\n    } else if (i % 5 === 0) {\n      console.log(\"Buzz\");\n    } else {\n      console.log(i);\n    }\n  }\n}\n// fizzBuzz();\n\nexport default [\n  reverseStringOpt,\n  isPalindromOpt,\n  capitalizeOpt,\n  revIntegerOpt,\n  mostCommonCharOpt\n];\n","// import { renderBlock } from \"./helpers\";\n// const FnOpt = [\n//   fn,\n//   fnCall,\n//   {\n//     title: '',\n//     description: ''\n//   },\n//   true || false || undefined\n// ];\n\n// longest word\nfunction longestWord(sen) {\n  const wArr = sen.toLowerCase().match(/[a-z0-9]+/g);\n  const sorted = wArr.sort((a, b) => b.length - a.length);\n  const long = sorted.filter((w) => w.length === sorted[0].length);\n  if (long.length > 1) return long;\n  return sorted[0];\n}\nconst stringLongestWord = `function longestWord(sen) {\n  const wArr = sen.toLowerCase().match(/[a-z0-9]+/g);\n  const sorted = wArr.sort((a, b) => b.length - a.length);\n  const long = sorted.filter((w) => w.length === sorted[0].length);\n  if (long.length > 1) return long;\n  return sorted[0];\n}`;\nconst longestWordOpt = [\n  stringLongestWord,\n  longestWord(\"helloo, there my name John\"),\n  {\n    title: \"Longest Word\",\n    description: 'longestWord(\"helloo, there my name John\")'\n  }\n];\n\n// array chunking\nfunction chunkArr(arr, len) {\n  const chunkedArr = [];\n  let i = 0;\n  while (i < arr.length) {\n    chunkedArr.push(arr.slice(i, i + len));\n    i += len;\n  }\n  return chunkedArr;\n}\nconst stringChunkArr = `function chunkArr(arr, len) {\n  const chunkedArr = [];\n  let i = 0;\n  while (i < arr.length) {\n    chunkedArr.push(arr.slice(i, i + len));\n    i += len;\n  }\n  return chunkedArr;\n}`;\nconst chunkArrOpt = [\n  stringChunkArr,\n  chunkArr([1, 2, 3, 4, 5, 6, 7], 2),\n  {\n    title: \"Chunk Array\",\n    description: \"chunkArr([1, 2, 3, 4, 5, 6, 7], 2)\"\n  }\n];\n\n// flatten array\nfunction flattenArr(arrays) {\n  // sol 1\n  // return arrays.reduce((a, b) => a.concat(b));\n  // sol 2\n  // return [].concat.apply([], arrays);\n  // sol 3\n  return [].concat(...arrays);\n}\nconst stringFlattenArr = `function flattenArr(arrays) {\n  // sol 1\n  // return arrays.reduce((a, b) => a.concat(b));\n  // sol 2\n  // return [].concat.apply([], arrays);\n  // sol 3\n  return [].concat(...arrays);\n}`;\nconst flattenArrOpt = [\n  stringFlattenArr,\n  flattenArr([[1, 2], [3, 4], [5, 6], [7]]),\n  {\n    title: \"Flatten Array\",\n    description: \"flattenArr([[1, 2], [3, 4], [5, 6], [7]])\"\n  }\n];\n\n// anagram\nfunction isAnagram(str1, str2) {\n  const case1 = str1.toLowerCase().split(\"\").sort().join();\n  const case2 = str2.toLowerCase().split(\"\").sort().join();\n  return case1 === case2;\n}\nconst stringIsAnagram = `function isAnagram(str1, str2) {\n  const case1 = str1.toLowerCase().split(\"\").sort().join();\n  const case2 = str2.toLowerCase().split(\"\").sort().join();\n  return case1 === case2;\n}`;\nconst isAnagramOpt = [\n  stringIsAnagram,\n  isAnagram(\"elbow\", \"below\"),\n  {\n    title: \"Check Anagram\",\n    description: 'isAnagram(\"elbow\", \"below\")'\n  }\n];\n\n// ass result need to extend Array constructor with custom method\n// to call like [].customMethod();\n// const newArray = Array(1, 2, 3, 4, 5);\nArray.prototype.duplicate = function () {\n  return [].concat(...this, ...this);\n};\nconst stringDuplicate = `Array.prototype.duplicate = function () {\n  return [].concat(...this, ...this);\n}`;\nconst duplicateArrOpt = [\n  stringDuplicate,\n  [1, 2, 3, 4, 5].duplicate(),\n  {\n    title: \"Duplicate Array\",\n    description: \"[1, 2, 3, 4, 5].duplicate()\"\n  }\n];\n\n// shift letters\nfunction shiftLetters(str) {\n  let newStr = str.toLowerCase().replace(/[a-z]/gi, (char) => {\n    if (char === \"z\" || char === \"Z\") {\n      return \"a\";\n    } else {\n      return String.fromCharCode(char.charCodeAt() + 1);\n    }\n  });\n  return newStr;\n}\nconst stringShiftLetters = `function shiftLetters(str) {\n  let newStr = str.toLowerCase().replace(/[a-z]/gi, (char) => {\n    if (char === \"z\" || char === \"Z\") {\n      return \"a\";\n    } else {\n      return String.fromCharCode(char.charCodeAt() + 1);\n    }\n  });\n  return newStr;\n}`;\nconst shiftLettersOpt = [\n  stringShiftLetters,\n  shiftLetters(\"hello thereZ\"),\n  {\n    title: \"Shift Letters\",\n    description: 'shiftLetters(\"hello thereZ\")'\n  }\n];\n\nexport default [\n  longestWordOpt,\n  chunkArrOpt,\n  flattenArrOpt,\n  isAnagramOpt,\n  duplicateArrOpt,\n  shiftLettersOpt\n];\n","// import { renderBlock } from \"./helpers\";\n// const FnOpt = [\n//   fn,\n//   fnCall,\n//   {\n//     title: '',\n//     description: ''\n//   },\n//   true || false || undefined\n// ];\n\nconst arrPrices = [200, 150, 300, 100, 90, 500];\n\nfunction sortPrice(prices) {\n  const filtered = prices.filter((p) => p >= 200);\n  return filtered.sort((a, b) => a > b);\n}\nconst stringsortPrice = `function sortPrice(prices) {\n  const filtered = prices.filter((p) => p >= 200);\n  return filtered.sort((a, b) => a > b);\n}`;\nconst sortPriceOpt = [\n  stringsortPrice,\n  sortPrice(arrPrices),\n  {\n    title: \"Sort Price\",\n    description: \"sortPrice(arrPrices)\"\n  }\n];\n\n//closure\nfunction closureFunc() {\n  let n = 1;\n  return function () {\n    return n++;\n  };\n}\nconst cl1 = closureFunc();\nconst stringClosureFn = `function closureFunc() {\n  let n = 1;\n  return function () {\n    return n++;\n  };\n}\nconst cl1 = closureFunc();`;\nconst closureFuncOpt = [\n  stringClosureFn,\n  cl1(),\n  {\n    title: \"Test closure function\",\n    description: \"cl1()\"\n  },\n  false\n];\n\n// Add all numbers (NO ARRAYS)\n// ex. addAll(1,3,5,9) === 18\nfunction addAll(...rest) {\n  return rest.reduce((sum, n) => sum + n);\n}\nconst stringAddAll = `function addAll(...rest) {\n  return rest.reduce((sum, n) => sum + n);\n}`;\nconst addAllOpt = [\n  stringAddAll,\n  addAll(1, 3, 5, 9),\n  {\n    title: \"Add all numbers\",\n    description: \"addAll(1, 3, 5, 9)\"\n  },\n  true\n];\n\n// Summary  of prime numbers\n// ex. sumPrimeNum(10) === 17\nfunction isPrime(num) {\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) return false;\n  }\n  return num > 1;\n}\nconst stringIsPrime = `function isPrime(num) {\n  for (let i = 2; i < num; i++) {\n    if (num % i === 0) return false;\n  }\n  return num > 1;\n}`;\nconst isPrimeOpt = [\n  stringIsPrime,\n  isPrime(4).toString(),\n  {\n    title: \"Check for prime numbers\",\n    description: \"isPrime(4)\"\n  },\n  true\n];\nfunction sumPrimeNum(num) {\n  let sum = 0;\n  for (let i = num; i > 1; i--) {\n    sum += isPrime(i) ? i : 0;\n  }\n  return sum;\n}\nconst stringSumPrimeNum = `function sumPrimeNum(num) {\n  let sum = 0;\n  for (let i = num; i > 1; i--) {\n    sum += isPrime(i) ? i : 0;\n  }\n  return sum;\n}`;\nconst sumPrimeNumOpt = [\n  stringSumPrimeNum,\n  sumPrimeNum(10),\n  {\n    title: \"Get sum of prime numbers\",\n    description: \"sumPrimeNum(10)\"\n  },\n  true\n];\n\nexport default [\n  sortPriceOpt,\n  closureFuncOpt,\n  addAllOpt,\n  sumPrimeNumOpt,\n  isPrimeOpt\n];\n","import tabCardio1 from \"./cardio1\";\nimport tabCardio2 from \"./cardio2\";\nimport tabCardio3 from \"./cardio3\";\n\nconst tabs = [\n  {\n    title: \"Tab 1\",\n    examples: tabCardio1\n  },\n  {\n    title: \"Tab 2\",\n    examples: tabCardio2\n  },\n  {\n    title: \"Tab 3\",\n    examples: tabCardio3\n  }\n];\n\nexport { tabs };\n","import { createElement } from \"../helpers/create\";\n\nconst Button = (props) => {\n  const { classname, title, attrs } = props;\n  const element = createElement(title, \"button\");\n  element.className = classname;\n  if (attrs) {\n    attrs.map((attr) => {\n      const attrName = Object.getOwnPropertyNames(attr)[0];\n      return element.setAttribute(attrName, attr[attrName]);\n    });\n  }\n\n  return element;\n};\n\nexport default Button;\n","import styles from \"../confStyles\";\nimport { createElement } from \"../helpers/create\";\nimport Button from \"./button\";\n\nconst Nav = (items) => {\n  const fragment = document.createDocumentFragment();\n\n  items.map(({ active, title, attrs }) => {\n    const classname = !active ? styles.nav.default : styles.nav.active;\n    const newItem = Button({ classname, title, attrs });\n    return fragment.appendChild(newItem);\n  });\n\n  const element = createElement(fragment, \"nav\");\n  element.className = styles.nav.container;\n\n  return element;\n};\n\nexport default Nav;\n","import config from \"./config\";\nimport {\n  handleDisplayCode,\n  handleActiveNavItem,\n  setCodeHighlights,\n  renderElement,\n  renderTab\n} from \"./helpers\";\nimport { tabs } from \"./view\";\nimport Nav from \"./components/nav\";\n\nconst { selector } = config;\nconst viewState = {};\nconst tabsRevers = tabs.reverse();\n\nif (tabsRevers) {\n  const tabIndex = tabsRevers.findIndex(({ active }) => !!active);\n  viewState.activeTabIndex = !tabIndex || tabIndex === -1 ? 0 : tabIndex;\n\n  viewState.navItems = [];\n  tabsRevers.map(({ title }, index) => {\n    return viewState.navItems.push({\n      title,\n      active: viewState.activeTabIndex === index,\n      attrs: [\n        {\n          [selector.navIndex]: index\n        }\n      ]\n    });\n  });\n} else {\n  viewState.activeTabIndex = 0;\n}\n\nconst highlightCode = () => {\n  const allCodeBlocks = Array.from(\n    document.querySelectorAll(selector.codeBlock)\n  );\n  allCodeBlocks.map((block) => setCodeHighlights(block));\n};\n\nconst nav = Nav(viewState.navItems);\n\nrenderElement(nav);\nrenderTab(tabsRevers, viewState.activeTabIndex);\nhighlightCode();\n\ndocument.addEventListener(\"click\", handleDisplayCode);\ndocument.addEventListener(\"click\", (event) => {\n  if (!event.target.getAttribute(selector.navIndex)) return;\n\n  const target = event.target;\n  viewState.activeTabIndex = parseInt(\n    target.getAttribute(selector.navIndex),\n    10\n  );\n\n  handleActiveNavItem(target);\n  renderTab(tabsRevers, viewState.activeTabIndex);\n  highlightCode();\n});\n"]}